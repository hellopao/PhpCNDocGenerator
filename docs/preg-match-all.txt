语法:
   int preg_match_all    ( string $pattern   , string $subject   [, array &$matches   [, int $flags = PREG_PATTERN_ORDER   [, int $offset = 0  ]]] )
说明:
搜索subject中所有匹配pattern给定正则表达式的匹配结果并且将它们以flag指定顺序输出到matches中.
参数:
  参数              pattern                  要搜索的模式，字符串形式。                        subject                  输入字符串。                        matches                 多维数组，作为输出参数输出所有匹配结果, 数组排序通过flags指定。                        flags                 可以结合下面标记使用(注意不能同时使用PREG_PATTERN_ORDER和      PREG_SET_ORDER)：                        PREG_PATTERN_ORDER                             结果排序为$matches[0]保存完整模式的所有匹配, $matches[1]          保存第一个子组的所有匹配，以此类推。                                           &lt;?phppreg_match_all("|&lt;[^&gt;]+&gt;(.*)&lt;/[^&gt;]+&gt;|U",&nbsp;&nbsp;&nbsp;&nbsp;"&lt;b&gt;example:&nbsp;&lt;/b&gt;&lt;div&nbsp;align=left&gt;this&nbsp;is&nbsp;a&nbsp;test&lt;/div&gt;",&nbsp;&nbsp;&nbsp;&nbsp;$out,&nbsp;PREG_PATTERN_ORDER);echo&nbsp;$out[0][0]&nbsp;.&nbsp;",&nbsp;"&nbsp;.&nbsp;$out[0][1]&nbsp;.&nbsp;"\n";echo&nbsp;$out[1][0]&nbsp;.&nbsp;",&nbsp;"&nbsp;.&nbsp;$out[1][1]&nbsp;.&nbsp;"\n";?&gt;
返回值:
  返回值    返回完整匹配次数（可能是0），或者如果发生错误返回FALSE。   
示例:

<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U",
    "<b>example: </b><div align=left>this is a test</div>",
    $out, PREG_PATTERN_ORDER);
echo $out[0][0] . ", " . $out[0][1] . "\n";
echo $out[1][0] . ", " . $out[1][1] . "\n";
?>

<b>example: </b>, <div align=left>this is a test</div>
example: , this is a test

<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U",
    "<b>example: </b><div align=\"left\">this is a test</div>",
    $out, PREG_SET_ORDER);
echo $out[0][0] . ", " . $out[0][1] . "\n";
echo $out[1][0] . ", " . $out[1][1] . "\n";
?>

<b>example: </b>, example:
<div align="left">this is a test</div>, this is a test

<?php
preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
                "Call 555-1212 or 1-800-555-1212", $phones);
?>

<?php
//\\2是一个后向引用的示例. 这会告诉pcre它必须匹配正则表达式中第二个圆括号(这里是([\w]+))
//匹配到的结果. 这里使用两个反斜线是因为这里使用了双引号.
$html = "<b>bold text</b><a href=howdy.html>click me</a>";
preg_match_all("/(<([\w]+)[^>]*>)(.*?)(<\/\\2>)/", $html, $matches, PREG_SET_ORDER);
foreach ($matches as $val) {
    echo "matched: " . $val[0] . "\n";
    echo "part 1: " . $val[1] . "\n";
    echo "part 2: " . $val[2] . "\n";
    echo "part 3: " . $val[3] . "\n";
    echo "part 4: " . $val[4] . "\n\n";
}
?>
以上例程会输出：
matched: <b>bold text</b>
part 1: <b>
part 2: b
part 3: bold text
part 4: </b>
matched: <a href=howdy.html>click me</a>
part 1: <a href=howdy.html>
part 2: a
part 3: click me
part 4: </a>

<?php
$str = <<<FOO
a: 1
b: 2
c: 3
FOO;
preg_match_all('/(?P<name>\w+): (?P<digit>\d+)/', $str, $matches);
/* 下面代码在php 5.2.2(pcre 7.0)或更高版本下工作, 不过, 为了向后兼容
 * 推荐使用上面的方式. */
// preg_match_all('/(?<name>\w+): (?<digit>\d+)/', $str, $matches);
print_r($matches);
?>
以上例程会输出：
Array
(
    [0] => Array
        (
            [0] => a: 1
            [1] => b: 2
            [2] => c: 3
        )
    [name] => Array
        (
            [0] => a
            [1] => b
            [2] => c
        )
    [1] => Array
        (
            [0] => a
            [1] => b
            [2] => c
        )
    [digit] => Array
        (
            [0] => 1
            [1] => 2
            [2] => 3
        )
    [2] => Array
        (
            [0] => 1
            [1] => 2
            [2] => 3
        )
)
