语法:
   bool ob_start    ([ callback $output_callback   [, int $chunk_size   [, bool $erase  ]]] )
说明:
此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。
参数:
  参数              output_callback                  可选参数 output_callback 函数可以被指定。        此函数把一个字符串当作参数并返回一个字符串。       当输出缓冲区被( ob_flush(), ob_clean() 或者相似的函数)冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。        当调用 output_callback 时，它将收到输出缓冲区的内容作为参数       并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。       如果这个 output_callback 不是一个可以调用的函数，此函数       会返回 FALSE 。                   如果回调函数有两个参数，第二个参数会由一个位域补充，该位域由       PHP_OUTPUT_HANDLER_START,       PHP_OUTPUT_HANDLER_CONT 和       PHP_OUTPUT_HANDLER_END 组成。                   如果 output_callback 返回 FALSE ，其原来的输入       内容被直接送到浏览器。                   这个参数 output_callback 可以通过直接给一个 NULL        值而避开。                   ob_end_clean(), ob_end_flush(),       ob_clean(), ob_flush() and       ob_start() 不能从一个回调函数中调用。       如果从回调函数中调用了它们，产生的行为是不明确的。       如果想要删除缓冲区的内容，从回调函数中返回一个&quot;&quot; (空字符串)。       更不能从一个回调函数中使用像print_r($expression, true)        或highlight_file($filename, true) 一样的输出缓冲函数。               Note:                在PHP 4.0.4中， ob_gzhandler() 被引入是为了简化把gz编码过         数据发送到支持压缩网页的浏览器。        ob_gzhandler() 会判定浏览器可以接受哪种类型的编码内容，并返回相应        的输出。                               chunk_size                  如果可选参数 chunk_size 被赋值了，在任何一个能引起缓冲区的长度等于       或超过 chunk_size 的输出操作后，缓冲区都会被刷送。       默认值 0 意味着函数仅在最后被调用，其余的特殊值可以将 chunk_size       从 1 设定到 4096。                        erase                  如果可选参数 erase 被赋成 FALSE，直到脚本执行完成缓冲区才被删除。       这使得，如果调用了冲刷和清洗（清除）函数，会抛出一个“notice”,并返回 FALSE 值。                     
返回值:
  返回值     成功时返回 TRUE， 或者在失败时返回 FALSE。   
示例:

<?php
function callback($buffer)
{
  // replace all the apples with oranges
  return (str_replace("apples", "oranges", $buffer));
}
ob_start("callback");
?>
<html>
<body>
<p>It's like comparing apples to oranges.</p>
</body>
</html>
<?php
ob_end_flush();
?>
以上例程会输出：
<html>
<body>
<p>It&#039;s like comparing oranges to oranges.</p>
</body>
</html>
