语法:
   array fgetcsv    ( resource $handle   [, int $length = 0   [, string $delimiter = &#039;,&#039;   [, string $enclosure = &#039;&quot;&#039;   [, string $escape = &#039;\\&#039;  ]]]] )
说明:
和fgets()类似，只除了fgetcsv()解析读入的行并找出CSV格式的字段然后返回一个包含这些字段的数组。
参数:
  参数              handle                  一个由 fopen()、popen() 或       fsockopen() 产生的有效文件指针。                        length                  必须大于 CVS 文件内最长的一行。在 PHP 5       中该参数是可选的。如果忽略（在 PHP 5.0.4 以后的版本中设为       0）该参数的话，那么长度就没有限制，不过可能会影响执行效率。                        delimiter                  设置字段分界符（只允许一个字符）。                        enclosure                  设置字段环绕符（只允许一个字符）。                        escape                  设置转义字符（只允许一个字符），默认是一个反斜杠。                     
返回值:
  返回值     返回包含读取字段的索引数组。    Note:            CSV 文件中的空行将被返回为一个包含有单个 null 字段的数组，不会被当成错误。       Note: 在读取在 Macintosh 电脑中或由其创建的文件时， 如果 PHP不能正确的识别行结束符，启用运行时配置可选项 auto_detect_line_endings也许可以解决此问题。     如果提供了无效的文件指针，fgetcsv() 会返回 NULL。   其他错误，包括碰到文件结束时返回 FALSE，。   
示例:

<?php
$row = 1;
if (($handle = fopen("test.csv", "r")) !== FALSE) {
    while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
        $num = count($data);
        echo "<p> $num fields in line $row: <br /></p>\n";
        $row++;
        for ($c=0; $c < $num; $c++) {
            echo $data[$c] . "<br />\n";
        }
    }
    fclose($handle);
}
?>
