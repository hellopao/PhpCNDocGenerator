语法:
   mixed preg_replace_callback    ( mixed $pattern   , callable $callback   , mixed $subject   [, int $limit = -1   [, int &$count  ]] )
说明:
这个函数的行为除了可以指定一个callback替代replacement进行替换字符串的计算，其他方面等同于preg_replace()。
参数:
  参数              pattern                 要搜索的模式，可以使字符串或一个字符串数组。                        callback                 一个回调函数，在每次需要替换时调用，调用时函数得到的参数是从subject      中匹配到的结果。回调函数返回真正参与替换的字符串。这是该回调函数的签名：                           string handler         ( array $matches        )
返回值:
  返回值    如果subject是一个数组，  preg_replace_callback()返回一个数组，其他情况返回字符串。  错误发生时返回 NULL。      如果查找到了匹配，返回替换后的目标字符串（或字符串数组）， 其他情况subject  将会无变化返回。    
示例:

<?php
/* 一个unix样式的命令行过滤器，用于将段落开始部分的大写字母转换为小写。 */
$fp = fopen("php://stdin", "r") or die("can't read stdin");
while (!feof($fp)) {
    $line = fgets($fp);
    $line = preg_replace_callback(
        '|<p>\s*\w|',
        function ($matches) {
            return strtolower($matches[0]);
        },
        $line
    );
    echo $line;
}
fclose($fp);
?>

<?php
// 将文本中的年份增加一年.
$text = "April fools day is 04/01/2002\n";
$text.= "Last christmas was 12/24/2001\n";
// 回调函数
function next_year($matches)
{
  // 通常: $matches[0]是完成的匹配
  // $matches[1]是第一个捕获子组的匹配
  // 以此类推
  return $matches[1].($matches[2]+1);
}
echo preg_replace_callback(
            "|(\d{2}/\d{2}/)(\d{4})|",
            "next_year",
            $text);
?>
以上例程会输出：
April fools day is 04/01/2003
Last christmas was 12/24/2002

<?php
$input = "plain [indent] deep [indent] deeper [/indent] deep [/indent] plain";
function parseTagsRecursive($input)
{
     /* 译注: 对此正则表达式分段分析
     * 首尾两个#是正则分隔符
     * \[indent] 匹配一个原文的[indent]
     * ((?:[^[]|\[(?!/?indent])|(?R))+)分析:
     *   (?:[^[]|\[(?!/?indent])分析:
     *  首先它是一个非捕获子组
     *   两个可选路径, 一个是非[字符, 另一个是[字符但后面紧跟着不是/indent或indent.
     *   (?R) 正则表达式递归
     *     \[/indent] 匹配结束的[/indent]
     * /
    $regex = '#\[indent]((?:[^[]|\[(?!/?indent])|(?R))+)\[/indent]#';
    if (is_array($input)) {
        $input = '<div style="margin-left: 10px">'.$input[1].'</div>';
    }
    return preg_replace_callback($regex, 'parseTagsRecursive', $input);
}
$output = parseTagsRecursive($input);
echo $output;
?>
